name: Windows CI

on:
  workflow_dispatch:

jobs:
  build-windows:
    runs-on: windows-latest
    timeout-minutes: 30
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: x86_64-pc-windows-msvc

      - name: Cache cargo registry
        uses: actions/cache@v4
        with:
          path: ~/.cargo/registry/index
          key: ${{ runner.os }}-cargo-registry-${{ hashFiles('**/Cargo.lock') }}

      - name: Cache cargo dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cargo/registry/cache
          key: ${{ runner.os }}-cargo-deps-${{ hashFiles('**/Cargo.lock') }}

      - name: Cache target directory
        uses: actions/cache@v4
        with:
          path: target
          key: ${{ runner.os }}-target-${{ hashFiles('**/Cargo.lock') }}

      - name: Build code
        run: cargo build --locked --verbose

      - name: Install cargo-nextest
        uses: taiki-e/install-action@nextest

      - name: Run tests with nextest
        id: test
        # 15分でタイムアウト (ジョブ全体の30分タイムアウトより短く設定)
        # テストがハングした場合でも、issue作成などの後処理を確実に実行するため
        timeout-minutes: 15
        continue-on-error: true
        run: |
          # nextest: 設定ファイル(.config/nextest.toml)でタイムアウト、fail-fast、failure-outputを設定済み
          cargo nextest run 2>&1 | Tee-Object -FilePath test_output.log
          exit $LASTEXITCODE

      - name: Parse test results
        if: always() && (steps.test.outcome == 'failure' || steps.test.outcome == 'cancelled' || steps.test.outcome == 'timed_out')
        id: test_summary
        shell: pwsh
        run: |
          # テスト結果を解析して構造化データを抽出
          if (Test-Path test_output.log) {
            $content = Get-Content -Path test_output.log -Raw -ErrorAction SilentlyContinue
            
            # 統計情報を抽出（nextest summary行から）
            $total = "不明"
            $passed = "不明"
            $failed = "不明"
            $timedOut = "不明"
            
            if ($content -match 'Summary.*?(\d+) tests run: (\d+) passed, (\d+) failed(?:, (\d+) timed out)?') {
              $total = $matches[1]
              $passed = $matches[2]
              $failed = $matches[3]
              $timedOut = if ($matches[4]) { $matches[4] } else { "0" }
            }
            
            # 失敗したテスト名を抽出
            $failedTestsList = @()
            $failMatches = [regex]::Matches($content, 'FAIL\s+(?:\[[\d.]+s\])?\s+\([\d/]+\)\s+([\w:]+(?:::[\w:]+)*)')
            foreach ($match in $failMatches) {
              $testName = $match.Groups[1].Value
              if ($testName -and $failedTestsList -notcontains $testName) {
                $failedTestsList += $testName
              }
            }
            
            # タイムアウトしたテストを抽出
            $timeoutMatches = [regex]::Matches($content, 'TIMEOUT\s+\[[\d.]+s\]\s+\([\d/]+\)\s+([\w:]+(?:::[\w:]+)*)')
            foreach ($match in $timeoutMatches) {
              $testName = $match.Groups[1].Value
              if ($testName -and $failedTestsList -notcontains $testName) {
                $failedTestsList += "$testName (タイムアウト)"
              }
            }
            
            # テストをカテゴリ別に分類
            $categorized = @{
              "Pipe Tests" = @()
              "CLI Integration Tests" = @()
              "Client Integration Tests" = @()
              "Interactive Mode Tests" = @()
              "Server Integration Tests" = @()
              "その他" = @()
            }
            
            foreach ($test in $failedTestsList) {
              if ($test -match 'pipe.*test|test.*pipe') {
                $categorized["Pipe Tests"] += $test
              } elseif ($test -match 'cli_integration') {
                $categorized["CLI Integration Tests"] += $test
              } elseif ($test -match 'client.*test|test.*client') {
                $categorized["Client Integration Tests"] += $test
              } elseif ($test -match 'interactive') {
                $categorized["Interactive Mode Tests"] += $test
              } elseif ($test -match 'server.*test|test.*server') {
                $categorized["Server Integration Tests"] += $test
              } else {
                $categorized["その他"] += $test
              }
            }
            
            # カテゴリ別リストを作成
            $categorizedList = ""
            foreach ($category in $categorized.Keys | Sort-Object) {
              $tests = $categorized[$category]
              if ($tests.Count -gt 0) {
                $categorizedList += "`n#### $category ($($tests.Count)件)`n"
                foreach ($test in $tests) {
                  $categorizedList += "- $test`n"
                }
              }
            }
            
            # GITHUB_OUTPUTに出力
            "total_tests=$total" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            "passed=$passed" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            "failed=$failed" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            "timed_out=$timedOut" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            
            "failed_tests_categorized<<EOF" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            $categorizedList | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            "EOF" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          }

      - name: Capture test failure summary
        if: always() && (steps.test.outcome == 'failure' || steps.test.outcome == 'cancelled' || steps.test.outcome == 'timed_out')
        id: test_output
        shell: pwsh
        run: |
          # GitHub issue用にログを取得（最大65000文字）
          if (Test-Path test_output.log) {
            $content = Get-Content -Path test_output.log -Raw -ErrorAction SilentlyContinue
            if ($content -and $content.Length -gt 65000) {
              $content = $content.Substring($content.Length - 65000)
            }
            if ($content) {
              "log<<EOF" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
              $content | Out-File -FilePath $env:GITHUB_OUTPUT -Append
              "EOF" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            }
          }

      - name: Upload test log artifacts
        if: always() && (steps.test.outcome == 'failure' || steps.test.outcome == 'cancelled' || steps.test.outcome == 'timed_out')
        uses: actions/upload-artifact@v4
        with:
          name: test-logs
          path: test_output.log
          retention-days: 30

      - name: Determine failure status
        if: always() && (steps.test.outcome == 'failure' || steps.test.outcome == 'cancelled' || steps.test.outcome == 'timed_out')
        id: failure_status
        shell: pwsh
        run: |
          # cancelled: ユーザーによる手動キャンセル
          # timed_out: timeout-minutesによる自動タイムアウト
          # どちらも「タイムアウト」としてユーザーに報告
          if ("${{ steps.test.outcome }}" -eq "cancelled" -or "${{ steps.test.outcome }}" -eq "timed_out") {
            "status_en=timed out" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            "status_ja=タイムアウトによりキャンセル" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          } else {
            "status_en=failed" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            "status_ja=失敗" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          }

      - name: Generate issue body
        if: always() && (steps.test.outcome == 'failure' || steps.test.outcome == 'cancelled' || steps.test.outcome == 'timed_out')
        id: issue_body
        shell: pwsh
        run: |
          # Python scriptを使用してissue本文を生成
          $issueBody = python3 .github/scripts/generate_test_failure_issue.py `
            --status-ja "${{ steps.failure_status.outputs.status_ja }}" `
            --total-tests "${{ steps.test_summary.outputs.total_tests }}" `
            --passed "${{ steps.test_summary.outputs.passed }}" `
            --failed "${{ steps.test_summary.outputs.failed }}" `
            --timed-out "${{ steps.test_summary.outputs.timed_out }}" `
            --failed-tests-categorized "${{ steps.test_summary.outputs.failed_tests_categorized }}" `
            --workflow "${{ github.workflow }}" `
            --job "${{ github.job }}" `
            --run-id "${{ github.run_id }}" `
            --run-attempt "${{ github.run_attempt }}" `
            --ref "${{ github.ref }}" `
            --commit "${{ github.sha }}" `
            --server-url "${{ github.server_url }}" `
            --repository "${{ github.repository }}" `
            --error-log "${{ steps.test_output.outputs.log }}"
          
          # GITHUB_OUTPUTに出力
          "body<<EOF" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          $issueBody | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "EOF" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

      - name: Create issue on failure
        if: always() && (steps.test.outcome == 'failure' || steps.test.outcome == 'cancelled' || steps.test.outcome == 'timed_out')
        uses: dacbd/create-issue-action@v1
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          title: "[CI] Windows build or test ${{ steps.failure_status.outputs.status_en }}"
          body: ${{ steps.issue_body.outputs.body }}
          labels: "ci,windows,auto-generated"
