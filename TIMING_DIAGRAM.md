# タイミングダイアグラム: ハイスピード再生の原因

## 正常な動作 (理想)

```
生成スレッド:
|<------ 36.62ms ------>|<------ 36.62ms ------>|<------ 36.62ms ------>|
[ 2048 frames @ 55930Hz ][ 2048 frames @ 55930Hz ][ 2048 frames @ 55930Hz ]
           ↓                      ↓                      ↓
    [リサンプリング]        [リサンプリング]        [リサンプリング]
           ↓                      ↓                      ↓
|<----- 36.62ms ----->|<----- 36.62ms ----->|<----- 36.62ms ----->|
[ ~1758 frames @ 48kHz][ ~1758 frames @ 48kHz][ ~1758 frames @ 48kHz]
  (3515 samples)         (3515 samples)         (3515 samples)

オーディオ再生:
|<-------------- 36.62ms -------------->|<-------------- 36.62ms -------------->|
[        3515 samples @ 48000Hz         ][        3515 samples @ 48000Hz         ]
```

**時間**: 36.62ms の音声コンテンツを 36.62ms で再生 = 1.0倍速 ✅


## 現在の実装 (問題あり) - シナリオ1

`cpal::BufferSize::Fixed(4224)` = **4224フレーム** (8448サンプル) の場合:

```
生成スレッド:
|<------ 36.62ms ------>|
[ 2048 frames @ 55930Hz ]
           ↓
    [リサンプリング]
           ↓
|<----- 36.62ms ----->|
[~1758 frames @ 48kHz]
   (3515 samples)
           ↓
     [channelに送信]

オーディオコールバック #1 (88ms毎に呼ばれる):
|<--------------------------------- 88.00ms --------------------------------->|
[ 3515 samples (36.62ms) ][ 4933 samples = 無音 (51.38ms) ][待機中...]
  ^^^^^^^^^^^^^^^^^^^^^^    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  実際のオーディオ           無音で埋められた部分
  
時間の流れ:
  - 88.00ms の実時間が経過
  - 36.62ms 分のオーディオコンテンツのみが再生された
  - 51.38ms は無音だった
  
結果: 36.62ms のコンテンツが 88.00ms かかる → 0.42倍速 (遅い!) ❌
```

**あれ？遅くなってしまう...**

## 現在の実装 (問題あり) - 再考

実は、問題は別の場所にあるかもしれない。`try_recv()` の挙動を考えると:

```
時刻 0ms:
  生成スレッド: バッファ#1 (3515 samples) を channel に送信完了
  
時刻 0-36ms:
  生成スレッド: バッファ#2 を生成中 (36.62ms かかる)
  
時刻 0ms:
  コールバック#1: try_recv() → バッファ#1 (3515 samples) 取得
                  3515 samples を再生
                  4933 samples を無音で埋める
                  
時刻 88ms:
  コールバック#2: try_recv() → バッファ#2 (3515 samples) 取得
                  3515 samples を再生
                  4933 samples を無音で埋める
```

この場合、88ms毎にコールバックされるが、生成は36.62ms毎なので、
多くのバッファがチャネルに溜まっていく。

**もしチャネルが満杯になったら?**
- `SyncSender::send()` はブロックする
- 生成スレッドが待たされる

## 別の仮説: 生成が速すぎる

```
もし生成スレッドが「リアルタイムではなく」できるだけ速く生成していたら:

時刻 0ms:     バッファ#1-8 すべて即座に生成 (channel満杯)
時刻 0ms:     コールバック#1: バッファ#1 使用
時刻 88ms:    コールバック#2: バッファ#2 使用
時刻 176ms:   コールバック#3: バッファ#3 使用
...

問題: 生成は瞬時に完了するが、再生は88ms毎
→ 生成側の「時間経過」が正しくカウントされていない可能性
```

## 真の原因候補: サンプル数のカウントミス

```rust
// player.rs で samples_played がインクリメントされる
self.samples_played += 1;  // これは 55930Hz のサンプル

// しかし、audio.rs でのタイミング判定は?
if player.current_sample() >= total_samples {
    println!("■  Playback complete");
    break;
}
```

もし `player.current_sample()` が速く増えすぎていたら?

**例**: 
- 本来: 167,792 サンプル @ 55930Hz = 3.00秒
- もし48000Hzとして扱ったら: 167,792 サンプル @ 48000Hz = 3.50秒 (逆に遅い)
- もし2倍速でカウントしたら: 167,792 サンプルを半分の時間で終了 = 1.5秒

## 実データによる検証が必要

診断ログが以下を明らかにする:
1. `data.len()` の実際の値 (4224 or 8448?)
2. 受信/使用/無音のサンプル数
3. 実際の再生時間
4. 加速係数

これらの数値から真の原因を特定できる。
